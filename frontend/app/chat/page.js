'use client'

import { useState, useRef, useEffect, useCallback, useMemo, memo } from 'react'
import { motion } from 'framer-motion'
import { useAuth } from '@/lib/auth-context'
import { useRouter } from 'next/navigation'
import dynamic from 'next/dynamic'

// API configuration
const API_BASE_URL = process.env.NEXT_PUBLIC_API_URL || 'http://localhost:8080/api'

// Lazy load Navigation component
const Navigation = dynamic(() => import('@/components/Navigation'), {
  loading: () => <div className="h-16 bg-primary animate-pulse"></div>
})

// Memoized message component for performance
const MessageItem = memo(({ message, isTyping = false }) => (
  <motion.div
    initial={{ opacity: 0, y: 20 }}
    animate={{ opacity: 1, y: 0 }}
    className={`flex ${message.type === 'user' ? 'justify-end' : 'justify-start'} mb-4`}
  >
    <div
      className={`max-w-xs lg:max-w-md xl:max-w-lg px-4 py-3 rounded-2xl ${
        message.type === 'user'
          ? 'bg-primary text-primary-content ml-auto'
          : 'bg-base-200 text-base-content'
      }`}
    >
      {message.type === 'bot' && (
        <div className="flex items-center mb-2">
          <span className="text-lg mr-2">ü§ñ</span>
          <span className="text-sm font-medium">MediLens AI</span>
          {message.timestamp && (
            <span className="text-xs opacity-60 ml-auto">
              {new Date(message.timestamp).toLocaleTimeString('bn-BD', {
                hour: '2-digit',
                minute: '2-digit'
              })}
            </span>
          )}
        </div>
      )}
      
      {message.type === 'user' && message.timestamp && (
        <div className="text-xs opacity-80 mb-1 text-right">
          {new Date(message.timestamp).toLocaleTimeString('bn-BD', {
            hour: '2-digit',
            minute: '2-digit'
          })}
        </div>
      )}
      
      <div className="whitespace-pre-wrap break-words">
        {isTyping ? (
          <div className="flex items-center">
            <span>‡¶ü‡¶æ‡¶á‡¶™ ‡¶ï‡¶∞‡¶õ‡¶ø</span>
            <div className="ml-2 flex space-x-1">
              <div className="w-2 h-2 bg-current rounded-full animate-bounce"></div>
              <div className="w-2 h-2 bg-current rounded-full animate-bounce" style={{ animationDelay: '0.1s' }}></div>
              <div className="w-2 h-2 bg-current rounded-full animate-bounce" style={{ animationDelay: '0.2s' }}></div>
            </div>
          </div>
        ) : (
          message.content
        )}
      </div>
    </div>
  </motion.div>
))

// Memoized chat item for performance
const ChatItem = memo(({ chat, isSelected, onSelect }) => (
  <div
    className={`p-3 border-b cursor-pointer hover:bg-base-300 transition-colors ${
      isSelected ? 'bg-base-300' : ''
    }`}
    onClick={onSelect}
  >
    <h4 className="text-sm font-medium truncate">
      {chat.title || `‡¶ö‡ßç‡¶Ø‡¶æ‡¶ü ${chat.id}`}
    </h4>
    <p className="text-xs text-base-content/60">
      {new Date(chat.createdAt).toLocaleDateString('bn-BD')}
    </p>
  </div>
))

export default function ChatPage() {
  const [messages, setMessages] = useState([])
  const [inputMessage, setInputMessage] = useState('')
  const [isTyping, setIsTyping] = useState(false)
  const [loading, setLoading] = useState(true)
  const [chatHistory, setChatHistory] = useState([])
  const [selectedChatId, setSelectedChatId] = useState(null)
  const [prescriptionData, setPrescriptionData] = useState(null)
  const [chatContext, setChatContext] = useState('')
  const [isSending, setIsSending] = useState(false) // New flag to prevent duplicate sends
  const [lastMessageId, setLastMessageId] = useState(null) // Track last message to prevent duplicates
  const messagesEndRef = useRef(null)
  const { currentUser, getToken } = useAuth()
  const router = useRouter()

  const scrollToBottom = useCallback(() => {
    messagesEndRef.current?.scrollIntoView({ behavior: 'smooth' })
  }, [])

  const debouncedScrollToBottom = useMemo(() => {
    let timeoutId
    return () => {
      clearTimeout(timeoutId)
      timeoutId = setTimeout(scrollToBottom, 100)
    }
  }, [scrollToBottom])

  useEffect(() => {
    debouncedScrollToBottom()
  }, [messages, debouncedScrollToBottom])

  useEffect(() => {
    if (currentUser) {
      // Check for prescription data from Google Lens
      const urlParams = new URLSearchParams(window.location.search)
      const source = urlParams.get('source')
      
      if (source === 'prescription') {
        const storedPrescriptionData = sessionStorage.getItem('prescriptionAnalysis')
        if (storedPrescriptionData) {
          try {
            const prescriptionAnalysis = JSON.parse(storedPrescriptionData)
            setPrescriptionData(prescriptionAnalysis)
            setChatContext('prescription')
            sessionStorage.removeItem('prescriptionAnalysis') // Clear after use
          } catch (error) {
            console.error('Error parsing prescription data:', error)
          }
        }
      }
      
      // Check for analysis context from localStorage
      const storedChatContext = localStorage.getItem('medilens_chat_context')
      if (storedChatContext) {
        try {
          const chatContextData = JSON.parse(storedChatContext)
          if (chatContextData.type === 'analysis_discussion' && chatContextData.analysis) {
            setPrescriptionData(chatContextData.analysis)
            setChatContext('analysis_discussion')
            
            // Set a detailed welcome message with analysis context
            const welcomeMessage = `üî¨ ‡¶™‡ßç‡¶∞‡ßá‡¶∏‡¶ï‡ßç‡¶∞‡¶ø‡¶™‡¶∂‡¶® ‡¶¨‡¶ø‡¶∂‡ßç‡¶≤‡ßá‡¶∑‡¶£ ‡¶•‡ßá‡¶ï‡ßá ‡¶Ü‡¶™‡¶®‡¶æ‡¶ï‡ßá ‡¶∏‡ßç‡¶¨‡¶æ‡¶ó‡¶§‡¶Æ!\n\n${chatContextData.fullReport || chatContextData.summary}\n\n‡¶è‡¶á ‡¶¨‡¶ø‡¶∂‡ßç‡¶≤‡ßá‡¶∑‡¶£ ‡¶®‡¶ø‡¶Ø‡¶º‡ßá ‡¶Ü‡¶™‡¶®‡¶æ‡¶∞ ‡¶ï‡ßã‡¶®‡ßã ‡¶™‡ßç‡¶∞‡¶∂‡ßç‡¶® ‡¶Ü‡¶õ‡ßá? ‡¶Ü‡¶Æ‡¶ø ‡¶∏‡¶æ‡¶π‡¶æ‡¶Ø‡ßç‡¶Ø ‡¶ï‡¶∞‡¶§‡ßá ‡¶™‡ßç‡¶∞‡¶∏‡ßç‡¶§‡ßÅ‡¶§! üí¨`
            
            setMessages([{
              id: 'welcome-analysis-' + Date.now(),
              type: 'bot',
              content: welcomeMessage,
              timestamp: new Date()
            }])
            
            localStorage.removeItem('medilens_chat_context') // Clear after use
            return // Don't continue with normal initialization
          }
        } catch (error) {
          console.error('Error parsing chat context data:', error)
        }
      }
      
      initializeChat()
    }
  }, [currentUser])

  const initializeChat = async () => {
    try {
      setLoading(true)
      await loadChatHistory()
      
      // Start with welcome message if no chat history
      if (messages.length === 0) {
        let welcomeMessage = '‡¶Ü‡¶∏‡¶∏‡¶æ‡¶≤‡¶æ‡¶Æ‡ßÅ ‡¶Ü‡¶≤‡¶æ‡¶á‡¶ï‡ßÅ‡¶Æ! üôè\n\n‡¶Ü‡¶Æ‡¶ø MediLens ‡¶è‡¶∞ AI ‡¶∏‡¶π‡¶æ‡¶Ø‡¶º‡¶ï‡•§ ‡¶Ü‡¶™‡¶®‡¶æ‡¶∞ ‡¶∏‡ßç‡¶¨‡¶æ‡¶∏‡ßç‡¶•‡ßç‡¶Ø ‡¶¨‡¶ø‡¶∑‡¶Ø‡¶º‡¶ï ‡¶Ø‡ßá‡¶ï‡ßã‡¶®‡ßã ‡¶™‡ßç‡¶∞‡¶∂‡ßç‡¶® ‡¶ï‡¶∞‡ßÅ‡¶® - ‡¶Ü‡¶Æ‡¶ø ‡¶¨‡¶æ‡¶Ç‡¶≤‡¶æ‡¶Ø‡¶º ‡¶∏‡¶æ‡¶π‡¶æ‡¶Ø‡ßç‡¶Ø ‡¶ï‡¶∞‡¶§‡ßá ‡¶™‡¶æ‡¶∞‡¶ø! ü©∫üíö'
        
        // If coming from prescription analysis, customize welcome message
        if (prescriptionData) {
          welcomeMessage = `üî¨ ‡¶™‡ßç‡¶∞‡ßá‡¶∏‡¶ï‡ßç‡¶∞‡¶ø‡¶™‡¶∂‡¶® ‡¶¨‡¶ø‡¶∂‡ßç‡¶≤‡ßá‡¶∑‡¶£ ‡¶•‡ßá‡¶ï‡ßá ‡¶Ü‡¶™‡¶®‡¶æ‡¶ï‡ßá ‡¶∏‡ßç‡¶¨‡¶æ‡¶ó‡¶§‡¶Æ!\n\n‡¶Ü‡¶Æ‡¶ø ‡¶Ü‡¶™‡¶®‡¶æ‡¶∞ ‡¶™‡ßç‡¶∞‡ßá‡¶∏‡¶ï‡ßç‡¶∞‡¶ø‡¶™‡¶∂‡¶® ‡¶¨‡¶ø‡¶∂‡ßç‡¶≤‡ßá‡¶∑‡¶£ ‡¶ï‡¶∞‡ßá‡¶õ‡¶ø ‡¶è‡¶¨‡¶Ç ‡¶è‡¶ñ‡¶® ‡¶Ü‡¶™‡¶®‡¶æ‡¶∞ ‡¶Ø‡ßá‡¶ï‡ßã‡¶®‡ßã ‡¶™‡ßç‡¶∞‡¶∂‡ßç‡¶®‡ßá‡¶∞ ‡¶â‡¶§‡ßç‡¶§‡¶∞ ‡¶¶‡¶ø‡¶§‡ßá ‡¶™‡ßç‡¶∞‡¶∏‡ßç‡¶§‡ßÅ‡¶§‡•§ ‡¶Ü‡¶™‡¶®‡¶ø ‡¶®‡¶ø‡¶Æ‡ßç‡¶®‡¶≤‡¶ø‡¶ñ‡¶ø‡¶§ ‡¶¨‡¶ø‡¶∑‡¶Ø‡¶º‡ßá ‡¶™‡ßç‡¶∞‡¶∂‡ßç‡¶® ‡¶ï‡¶∞‡¶§‡ßá ‡¶™‡¶æ‡¶∞‡ßá‡¶®:\n\n‚Ä¢ ‡¶ì‡¶∑‡ßÅ‡¶ß‡ßá‡¶∞ ‡¶™‡¶æ‡¶∞‡ßç‡¶∂‡ßç‡¶¨‡¶™‡ßç‡¶∞‡¶§‡¶ø‡¶ï‡ßç‡¶∞‡¶ø‡¶Ø‡¶º‡¶æ\n‚Ä¢ ‡¶∏‡ßá‡¶¨‡¶®‡¶¨‡¶ø‡¶ß‡¶ø ‡¶∏‡¶Æ‡ßç‡¶™‡¶∞‡ßç‡¶ï‡ßá\n‚Ä¢ ‡¶ñ‡¶æ‡¶¶‡ßç‡¶Ø‡¶æ‡¶≠‡ßç‡¶Ø‡¶æ‡¶∏ ‡¶ì ‡¶∏‡¶§‡¶∞‡ßç‡¶ï‡¶§‡¶æ\n‚Ä¢ ‡¶¨‡¶ø‡¶ï‡¶≤‡ßç‡¶™ ‡¶ö‡¶ø‡¶ï‡¶ø‡ßé‡¶∏‡¶æ\n‚Ä¢ ‡¶™‡¶∞‡ßÄ‡¶ï‡ßç‡¶∑‡¶æ-‡¶®‡¶ø‡¶∞‡ßÄ‡¶ï‡ßç‡¶∑‡¶æ ‡¶∏‡¶Æ‡ßç‡¶™‡¶∞‡ßç‡¶ï‡ßá\n\n‡¶ï‡ßÄ ‡¶ú‡¶æ‡¶®‡¶§‡ßá ‡¶ö‡¶æ‡¶®? üí¨`
          
          // Also add prescription summary as a system message
          if (prescriptionData.summary) {
            setMessages([
              {
                id: 'welcome-' + Date.now(),
                type: 'bot',
                content: welcomeMessage,
                timestamp: new Date()
              },
              {
                id: 'prescription-' + Date.now(),
                type: 'system',
                content: prescriptionData.summary,
                timestamp: new Date(),
                isHidden: true // This will be used for context but not displayed
              }
            ])
            return
          }
        }
        
        setMessages([{
          id: 'welcome-' + Date.now(),
          type: 'bot',
          content: welcomeMessage,
          timestamp: new Date()
        }])
      }
    } catch (error) {
      console.error('Error initializing chat:', error)
    } finally {
      setLoading(false)
    }
  }

  const loadChatHistory = async () => {
    try {
      const token = getToken()
      const response = await fetch(`${API_BASE_URL}/user/chat`, {
        headers: {
          'Authorization': `Bearer ${token}`,
          'Content-Type': 'application/json',
        },
      })

      if (response.ok) {
        const chats = await response.json()
        setChatHistory(chats)
        
        // If there are existing chats, load the most recent one (only if not coming from prescription)
        if (chats.length > 0 && !prescriptionData) {
          const latestChat = chats[0]
          setSelectedChatId(latestChat.id)
          await loadChatMessages(latestChat.id)
        }
      }
    } catch (error) {
      console.error('Error loading chat history:', error)
    }
  }

  const loadChatMessages = async (chatId) => {
    try {
      const token = getToken()
      const response = await fetch(`${API_BASE_URL}/chat/${chatId}`, {
        headers: {
          'Authorization': `Bearer ${token}`,
          'Content-Type': 'application/json',
        },
      })

      if (response.ok) {
        const chatData = await response.json()
        const formattedMessages = chatData.messages?.map(msg => ({
          id: msg.id,
          type: msg.role === 'USER' ? 'user' : 'bot',
          content: msg.message,
          timestamp: new Date(msg.createdAt)
        })) || []
        
        // Sort messages by timestamp (oldest first)
        formattedMessages.sort((a, b) => new Date(a.timestamp) - new Date(b.timestamp))
        
        setMessages(formattedMessages)
      }
    } catch (error) {
      console.error('Error loading chat messages:', error)
    }
  }

  const generateChatTitle = async (messages) => {
    if (!messages || messages.length === 0) return '‡¶®‡¶§‡ßÅ‡¶® ‡¶ö‡ßç‡¶Ø‡¶æ‡¶ü'
    
    // Get first few user messages to understand the conversation topic
    const userMessages = messages.filter(msg => msg.sender === 'user').slice(0, 3)
    const conversationContext = userMessages.map(msg => msg.content).join(' ')
    
    try {
      // Use AI to generate a meaningful title based on conversation content
      const response = await fetch('/api/generate-chat-title', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify({
          conversation: conversationContext,
          prescriptionContext: prescriptionData ? 'prescription_analysis' : 'general_health',
          chatContext: chatContext
        }),
      })

      if (response.ok) {
        const data = await response.json()
        return data.title || generateFallbackTitle(conversationContext)
      }
    } catch (error) {
      console.error('Error generating AI title:', error)
    }

    // Fallback to intelligent local title generation
    return generateFallbackTitle(conversationContext)
  }

  const generateFallbackTitle = (conversationText) => {
    if (!conversationText) return '‡¶®‡¶§‡ßÅ‡¶® ‡¶ö‡ßç‡¶Ø‡¶æ‡¶ü'
    
    const text = conversationText.toLowerCase()
    
    // Medical conditions with emojis
    const conditionMatches = [
      { keywords: ['‡¶ú‡ßç‡¶¨‡¶∞', 'fever', '‡¶§‡¶æ‡¶™‡¶Æ‡¶æ‡¶§‡ßç‡¶∞‡¶æ'], title: 'üå°Ô∏è ‡¶ú‡ßç‡¶¨‡¶∞ ‡¶ì ‡¶§‡¶æ‡¶™‡¶Æ‡¶æ‡¶§‡ßç‡¶∞‡¶æ' },
      { keywords: ['‡¶Æ‡¶æ‡¶•‡¶æ‡¶¨‡ßç‡¶Ø‡¶•‡¶æ', 'headache', '‡¶Æ‡¶æ‡¶•‡¶æ ‡¶¨‡ßç‡¶Ø‡¶•‡¶æ'], title: 'üß† ‡¶Æ‡¶æ‡¶•‡¶æ‡¶¨‡ßç‡¶Ø‡¶•‡¶æ‡¶∞ ‡¶∏‡¶Æ‡¶∏‡ßç‡¶Ø‡¶æ' },
      { keywords: ['‡¶°‡¶æ‡¶Ø‡¶º‡¶æ‡¶¨‡ßá‡¶ü‡¶ø‡¶∏', 'diabetes', '‡¶ö‡¶ø‡¶®‡¶ø', '‡¶∏‡ßÅ‡¶ó‡¶æ‡¶∞'], title: 'üçé ‡¶°‡¶æ‡¶Ø‡¶º‡¶æ‡¶¨‡ßá‡¶ü‡¶ø‡¶∏ ‡¶®‡¶ø‡¶Ø‡¶º‡¶®‡ßç‡¶§‡ßç‡¶∞‡¶£' },
      { keywords: ['‡¶∞‡¶ï‡ßç‡¶§‡¶ö‡¶æ‡¶™', 'pressure', '‡¶π‡¶æ‡¶á‡¶™‡ßç‡¶∞‡ßá‡¶∂‡¶æ‡¶∞'], title: 'ü©∫ ‡¶∞‡¶ï‡ßç‡¶§‡¶ö‡¶æ‡¶™ ‡¶¨‡ßç‡¶Ø‡¶¨‡¶∏‡ßç‡¶•‡¶æ‡¶™‡¶®‡¶æ' },
      { keywords: ['‡¶ï‡¶æ‡¶∂‡¶ø', 'cough', '‡¶ñ‡ßÅ‡¶∏‡¶ñ‡ßÅ‡¶∏‡¶æ‡¶®‡¶ø'], title: 'üò∑ ‡¶ï‡¶æ‡¶∂‡¶ø ‡¶ì ‡¶∂‡ßç‡¶¨‡¶æ‡¶∏‡¶ï‡¶∑‡ßç‡¶ü' },
      { keywords: ['‡¶™‡ßá‡¶ü', 'stomach', '‡¶ó‡ßç‡¶Ø‡¶æ‡¶∏', '‡¶π‡¶ú‡¶Æ'], title: 'üçΩÔ∏è ‡¶™‡ßá‡¶ü ‡¶ì ‡¶π‡¶ú‡¶Æ‡ßá‡¶∞ ‡¶∏‡¶Æ‡¶∏‡ßç‡¶Ø‡¶æ' },
      { keywords: ['‡¶π‡ßÉ‡¶¶‡¶∞‡ßã‡¶ó', 'heart', '‡¶¨‡ßÅ‡¶ï‡ßá ‡¶¨‡ßç‡¶Ø‡¶•‡¶æ'], title: '‚ù§Ô∏è ‡¶π‡ßÉ‡¶¶‡¶∞‡ßã‡¶ó ‡¶™‡¶∞‡¶æ‡¶Æ‡¶∞‡ßç‡¶∂' },
      { keywords: ['‡¶Ö‡ßç‡¶Ø‡¶æ‡¶≤‡¶æ‡¶∞‡ßç‡¶ú‡¶ø', 'allergy', '‡¶ö‡ßÅ‡¶≤‡¶ï‡¶æ‡¶®‡¶ø'], title: 'ü§ß ‡¶Ö‡ßç‡¶Ø‡¶æ‡¶≤‡¶æ‡¶∞‡ßç‡¶ú‡¶ø ‡¶∏‡¶Æ‡¶∏‡ßç‡¶Ø‡¶æ' },
      { keywords: ['‡¶§‡ßç‡¶¨‡¶ï', 'skin', '‡¶ö‡¶∞‡ßç‡¶Æ‡¶∞‡ßã‡¶ó'], title: 'üß¥ ‡¶§‡ßç‡¶¨‡¶ï‡ßá‡¶∞ ‡¶∏‡¶Æ‡¶∏‡ßç‡¶Ø‡¶æ' },
      { keywords: ['‡¶ö‡ßã‡¶ñ', 'eye', '‡¶¶‡ßÉ‡¶∑‡ßç‡¶ü‡¶ø'], title: 'üëÅÔ∏è ‡¶ö‡ßã‡¶ñ‡ßá‡¶∞ ‡¶™‡¶∞‡¶æ‡¶Æ‡¶∞‡ßç‡¶∂' },
      { keywords: ['‡¶¶‡¶æ‡¶Å‡¶§', 'teeth', '‡¶Æ‡¶æ‡¶°‡¶º‡¶ø'], title: 'ü¶∑ ‡¶¶‡¶æ‡¶Å‡¶§ ‡¶ì ‡¶Æ‡ßÅ‡¶ñ‡ßá‡¶∞ ‡¶∏‡ßç‡¶¨‡¶æ‡¶∏‡ßç‡¶•‡ßç‡¶Ø' },
      { keywords: ['‡¶™‡ßç‡¶∞‡ßá‡¶∏‡¶ï‡ßç‡¶∞‡¶ø‡¶™‡¶∂‡¶®', '‡¶ì‡¶∑‡ßÅ‡¶ß', 'medicine'], title: 'üíä ‡¶ì‡¶∑‡ßÅ‡¶ß ‡¶ì ‡¶™‡ßç‡¶∞‡ßá‡¶∏‡¶ï‡ßç‡¶∞‡¶ø‡¶™‡¶∂‡¶®' },
      { keywords: ['‡¶ó‡¶∞‡ßç‡¶≠‡¶æ‡¶¨‡¶∏‡ßç‡¶•‡¶æ', 'pregnancy', '‡¶Æ‡¶æ'], title: 'ü§± ‡¶ó‡¶∞‡ßç‡¶≠‡¶æ‡¶¨‡¶∏‡ßç‡¶•‡¶æ ‡¶™‡¶∞‡¶æ‡¶Æ‡¶∞‡ßç‡¶∂' },
      { keywords: ['‡¶∂‡¶ø‡¶∂‡ßÅ', 'baby', '‡¶¨‡¶æ‡¶ö‡ßç‡¶ö‡¶æ'], title: 'ÔøΩ ‡¶∂‡¶ø‡¶∂‡ßÅ ‡¶∏‡ßç‡¶¨‡¶æ‡¶∏‡ßç‡¶•‡ßç‡¶Ø' }
    ]

    // Check for condition matches
    for (const condition of conditionMatches) {
      if (condition.keywords.some(keyword => text.includes(keyword))) {
        return condition.title
      }
    }

    // If it's a prescription context
    if (chatContext === 'prescription' || prescriptionData) {
      return 'ÔøΩ ‡¶™‡ßç‡¶∞‡ßá‡¶∏‡¶ï‡ßç‡¶∞‡¶ø‡¶™‡¶∂‡¶® ‡¶¨‡¶ø‡¶∂‡ßç‡¶≤‡ßá‡¶∑‡¶£'
    }
    
    // Extract meaningful words and create title
    const meaningfulWords = conversationText
      .replace(/[^\u0980-\u09FF\w\s]/g, '') // Keep Bengali and English characters
      .split(' ')
      .filter(word => word.length > 2)
      .slice(0, 3)
      .join(' ')
    
    if (meaningfulWords.length > 0) {
      return meaningfulWords.length > 25 ? 
        meaningfulWords.substring(0, 25) + '...' : 
        meaningfulWords
    }

    return '‡¶∏‡ßç‡¶¨‡¶æ‡¶∏‡ßç‡¶•‡ßç‡¶Ø ‡¶™‡¶∞‡¶æ‡¶Æ‡¶∞‡ßç‡¶∂'
  }

  const createNewChat = async (firstMessage = null) => {
    try {
      // Clear current messages and create new chat
      let welcomeContent = '‚ú® ‡¶®‡¶§‡ßÅ‡¶® ‡¶ö‡ßç‡¶Ø‡¶æ‡¶ü ‡¶∂‡ßÅ‡¶∞‡ßÅ ‡¶π‡¶Ø‡¶º‡ßá‡¶õ‡ßá!\n\n‡¶Ü‡¶™‡¶®‡¶æ‡¶∞ ‡¶∏‡ßç‡¶¨‡¶æ‡¶∏‡ßç‡¶•‡ßç‡¶Ø ‡¶¨‡¶ø‡¶∑‡¶Ø‡¶º‡¶ï ‡¶Ø‡ßá‡¶ï‡ßã‡¶®‡ßã ‡¶™‡ßç‡¶∞‡¶∂‡ßç‡¶® ‡¶ï‡¶∞‡ßÅ‡¶®‡•§ ‡¶Ü‡¶Æ‡¶ø ‡¶∏‡¶æ‡¶π‡¶æ‡¶Ø‡ßç‡¶Ø ‡¶ï‡¶∞‡¶§‡ßá ‡¶™‡ßç‡¶∞‡¶∏‡ßç‡¶§‡ßÅ‡¶§! ü©∫'
      
      if (prescriptionData) {
        welcomeContent = 'üî¨ ‡¶™‡ßç‡¶∞‡ßá‡¶∏‡¶ï‡ßç‡¶∞‡¶ø‡¶™‡¶∂‡¶® ‡¶¨‡¶ø‡¶∂‡ßç‡¶≤‡ßá‡¶∑‡¶£ ‡¶ö‡ßç‡¶Ø‡¶æ‡¶ü ‡¶∂‡ßÅ‡¶∞‡ßÅ!\n\n‡¶Ü‡¶™‡¶®‡¶æ‡¶∞ ‡¶™‡ßç‡¶∞‡ßá‡¶∏‡¶ï‡ßç‡¶∞‡¶ø‡¶™‡¶∂‡¶® ‡¶∏‡¶Æ‡ßç‡¶™‡¶∞‡ßç‡¶ï‡ßá ‡¶Ø‡ßá‡¶ï‡ßã‡¶®‡ßã ‡¶™‡ßç‡¶∞‡¶∂‡ßç‡¶® ‡¶ï‡¶∞‡ßÅ‡¶®‡•§ ‡¶Ü‡¶Æ‡¶ø ‡¶∏‡¶æ‡¶π‡¶æ‡¶Ø‡ßç‡¶Ø ‡¶ï‡¶∞‡¶§‡ßá ‡¶™‡ßç‡¶∞‡¶∏‡ßç‡¶§‡ßÅ‡¶§! üíä'
      }
      
      setMessages([{
        id: 'welcome-' + Date.now(),
        type: 'bot',
        content: welcomeContent,
        timestamp: new Date()
      }])
      
      setSelectedChatId(null) // Reset selected chat
      
      // Create new chat in backend with smart title
      const token = getToken()
      let chatTitle = '‡¶®‡¶§‡ßÅ‡¶® ‡¶ö‡ßç‡¶Ø‡¶æ‡¶ü'
      
      // Generate title based on first message if provided
      if (firstMessage) {
        chatTitle = generateFallbackTitle(firstMessage)
      } else if (prescriptionData) {
        chatTitle = 'üíä ‡¶™‡ßç‡¶∞‡ßá‡¶∏‡¶ï‡ßç‡¶∞‡¶ø‡¶™‡¶∂‡¶® ‡¶¨‡¶ø‡¶∂‡ßç‡¶≤‡ßá‡¶∑‡¶£'
      }
      
      const response = await fetch(`${API_BASE_URL}/chat/create`, {
        method: 'POST',
        headers: {
          'Authorization': `Bearer ${token}`,
          'Content-Type': 'application/json',
        },
        body: JSON.stringify({
          title: chatTitle,
          context: chatContext || 'general'
        })
      })

      if (response.ok) {
        const newChatId = await response.text()
        setSelectedChatId(parseInt(newChatId))
        await loadChatHistory()
        return parseInt(newChatId)
      }
    } catch (error) {
      console.error('Error creating new chat:', error)
      setSelectedChatId(null)
    }
    return null
  }

  const updateChatTitle = async (chatId, messages) => {
    if (!chatId || !messages || messages.length < 3) return

    try {
      const userMessages = messages.filter(msg => msg.sender === 'user')
      if (userMessages.length < 2) return

      const newTitle = await generateChatTitle(messages)
      const token = getToken()
      
      await fetch(`${API_BASE_URL}/chat/${chatId}/title`, {
        method: 'PUT',
        headers: {
          'Authorization': `Bearer ${token}`,
          'Content-Type': 'application/json',
        },
        body: JSON.stringify({ title: newTitle })
      })

      // Update local chat history
      setChatHistory(prev => prev.map(chat => 
        chat.id === chatId ? { ...chat, title: newTitle } : chat
      ))
    } catch (error) {
      console.error('Error updating chat title:', error)
    }
  }

  const sendMessageToBackend = async (message, chatId) => {
    try {
      const token = getToken()
      
      // Save user message to backend first if we have a chatId
      if (chatId) {
        try {
          const userMessageData = {
            role: 'USER',
            message: message
          }
          
          await fetch(`${API_BASE_URL}/chat/${chatId}`, {
            method: 'POST',
            headers: {
              'Authorization': `Bearer ${token}`,
              'Content-Type': 'application/json',
            },
            body: JSON.stringify(userMessageData),
          })
        } catch (error) {
          console.log('Failed to save user message to backend:', error)
        }
      }
      
      // Prepare context for AI - include prescription data if available
      let chatHistoryForAI = messages.slice(-10)
      if (prescriptionData && prescriptionData.summary) {
        chatHistoryForAI = [
          {
            type: 'system',
            content: `‡¶™‡ßç‡¶∞‡ßá‡¶∏‡¶ï‡ßç‡¶∞‡¶ø‡¶™‡¶∂‡¶® ‡¶™‡ßç‡¶∞‡¶∏‡¶ô‡ßç‡¶ó: ${prescriptionData.summary}`
          },
          ...chatHistoryForAI
        ]
      }
      
      // Get AI response from medical chat API
      const medicalChatResponse = await fetch('/api/medical-chat', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify({
          message: message,
          chatHistory: chatHistoryForAI,
          context: chatContext || 'general',
          prescriptionData: prescriptionData ? {
            medications: prescriptionData.analysis?.medications || [],
            diagnosis: prescriptionData.analysis?.primaryDiagnosis || null,
            investigations: prescriptionData.analysis?.investigations || []
          } : null
        })
      })

      if (medicalChatResponse.ok) {
        const aiResult = await medicalChatResponse.json()
        if (aiResult.success && aiResult.response) {
          
          // Save bot response to backend if we have a chatId
          if (chatId) {
            try {
              const botMessageData = {
                role: 'ASSISTANT',
                message: aiResult.response
              }
              
              await fetch(`${API_BASE_URL}/chat/${chatId}`, {
                method: 'POST',
                headers: {
                  'Authorization': `Bearer ${token}`,
                  'Content-Type': 'application/json',
                },
                body: JSON.stringify(botMessageData),
              })
            } catch (error) {
              console.log('Failed to save bot response to backend:', error)
            }
          }
          
          return aiResult.response
        }
      }
      
      // Fallback to local enhanced response
      return getEnhancedLocalResponse(message)
      
    } catch (error) {
      console.error('Error sending message:', error)
      return getEnhancedLocalResponse(message)
    }
  }

  const handleSendMessage = useCallback(async (e) => {
    e.preventDefault()
    if (!inputMessage.trim() || isTyping || isSending) return

    const currentMessage = inputMessage.trim()
    const messageId = 'user-' + Date.now() + '-' + Math.random().toString(36).substr(2, 9)
    
    // Prevent duplicate messages
    if (lastMessageId === messageId) return
    setLastMessageId(messageId)
    
    const userMessage = {
      id: messageId,
      type: 'user',
      content: currentMessage,
      timestamp: new Date(),
      sender: 'user'
    }

    // Prevent concurrent sends
    setIsSending(true)
    
    // Optimistically add user message
    setMessages(prev => {
      // Check if message already exists
      if (prev.some(msg => msg.id === messageId)) {
        return prev
      }
      return [...prev, userMessage]
    })
    
    setInputMessage('')
    setIsTyping(true)

    try {
      let currentChatId = selectedChatId
      
      // Create new chat if none exists
      if (!currentChatId) {
        currentChatId = await createNewChat(currentMessage)
        if (!currentChatId) {
          throw new Error('Failed to create chat')
        }
      }

      // Send message to backend and get AI response
      const botResponseContent = await sendMessageToBackend(currentMessage, currentChatId)
      
      const botMessage = {
        id: 'bot-' + Date.now() + '-' + Math.random().toString(36).substr(2, 9),
        type: 'bot',
        content: botResponseContent,
        timestamp: new Date(),
        sender: 'bot'
      }
      
      setMessages(prev => {
        // Check if bot response already exists
        if (prev.some(msg => msg.content === botResponseContent && msg.sender === 'bot' && 
                          Math.abs(new Date(msg.timestamp) - new Date()) < 5000)) {
          return prev
        }
        return [...prev, botMessage]
      })
      
      // Update chat title intelligently (only after meaningful conversation)
      const newMessageCount = messages.filter(m => m.sender === 'user').length + 1
      if (newMessageCount === 2) {
        // Update title after second message for better context
        setTimeout(() => {
          const allMessages = [...messages, userMessage, botMessage]
          updateChatTitle(currentChatId, allMessages)
        }, 1500)
      }
      
      // Refresh chat history periodically, not every message (performance optimization)
      if (newMessageCount % 3 === 0) {
        setTimeout(loadChatHistory, 2000)
      }
      
    } catch (error) {
      console.error('Error handling message:', error)
      
      // Enhanced fallback response
      const fallbackResponse = {
        id: 'bot-' + Date.now() + '-' + Math.random().toString(36).substr(2, 9),
        type: 'bot',
        content: '‚ö†Ô∏è ‡¶¶‡ßÅ‡¶É‡¶ñ‡¶ø‡¶§, ‡¶∏‡¶Ç‡¶Ø‡ßã‡¶ó‡ßá ‡¶∏‡¶Æ‡¶∏‡ßç‡¶Ø‡¶æ ‡¶π‡¶ö‡ßç‡¶õ‡ßá‡•§ ‡¶Ü‡¶™‡¶®‡¶æ‡¶∞ ‡¶™‡ßç‡¶∞‡¶∂‡ßç‡¶® ‡¶Ü‡¶¨‡¶æ‡¶∞ ‡¶ï‡¶∞‡ßÅ‡¶® ‡¶Ö‡¶•‡¶¨‡¶æ ‡¶ï‡¶ø‡¶õ‡ßÅ‡¶ï‡ßç‡¶∑‡¶£ ‡¶™‡¶∞ ‡¶ö‡ßá‡¶∑‡ßç‡¶ü‡¶æ ‡¶ï‡¶∞‡ßÅ‡¶®‡•§ üîÑ',
        timestamp: new Date(),
        sender: 'bot'
      }
      
      setMessages(prev => [...prev, fallbackResponse])
    } finally {
      setIsTyping(false)
      setIsSending(false)
    }
  }, [inputMessage, isTyping, isSending, selectedChatId, messages, createNewChat, sendMessageToBackend, updateChatTitle, loadChatHistory, lastMessageId])

  const getEnhancedLocalResponse = (message) => {
    const lowerMessage = message.toLowerCase()
    
    // Enhanced prescription responses if prescription data is available
    if (prescriptionData) {
      if (lowerMessage.includes('‡¶ì‡¶∑‡ßÅ‡¶ß') || lowerMessage.includes('medicine') || lowerMessage.includes('medication')) {
        const medications = prescriptionData.analysis?.medications || []
        if (medications.length > 0) {
          let response = "‡¶Ü‡¶™‡¶®‡¶æ‡¶∞ ‡¶™‡ßç‡¶∞‡ßá‡¶∏‡¶ï‡ßç‡¶∞‡¶ø‡¶™‡¶∂‡¶®‡ßá‡¶∞ ‡¶ì‡¶∑‡ßÅ‡¶ß ‡¶∏‡¶Æ‡ßç‡¶™‡¶∞‡ßç‡¶ï‡ßá ‡¶§‡¶•‡ßç‡¶Ø:\n\n"
          medications.forEach((med, index) => {
            response += `${index + 1}. **${med.prescribedName || med.genericName}**\n`
            if (med.strength) response += `   ‡¶∂‡¶ï‡ßç‡¶§‡¶ø: ${med.strength}\n`
            if (med.frequency) response += `   ‡¶∏‡ßá‡¶¨‡¶®‡¶¨‡¶ø‡¶ß‡¶ø: ${med.frequency}\n`
            if (med.purpose) response += `   ‡¶ï‡¶æ‡¶ú: ${med.purpose}\n\n`
          })
          response += "‡¶Ü‡¶∞‡ßã ‡¶ï‡ßã‡¶® ‡¶™‡ßç‡¶∞‡¶∂‡ßç‡¶® ‡¶•‡¶æ‡¶ï‡¶≤‡ßá ‡¶ú‡¶æ‡¶®‡¶æ‡¶®! üíä"
          return response
        }
      }
      
      if (lowerMessage.includes('‡¶™‡¶æ‡¶∞‡ßç‡¶∂‡ßç‡¶¨') || lowerMessage.includes('side effect')) {
        return `‡¶Ü‡¶™‡¶®‡¶æ‡¶∞ ‡¶™‡ßç‡¶∞‡ßá‡¶∏‡¶ï‡ßç‡¶∞‡¶ø‡¶™‡¶∂‡¶®‡ßá‡¶∞ ‡¶ì‡¶∑‡ßÅ‡¶ß‡ßá‡¶∞ ‡¶™‡¶æ‡¶∞‡ßç‡¶∂‡ßç‡¶¨‡¶™‡ßç‡¶∞‡¶§‡¶ø‡¶ï‡ßç‡¶∞‡¶ø‡¶Ø‡¶º‡¶æ ‡¶∏‡¶Æ‡ßç‡¶™‡¶∞‡ßç‡¶ï‡ßá:\n\n‚Ä¢ ‡¶Ø‡ßá‡¶ï‡ßã‡¶® ‡¶®‡¶§‡ßÅ‡¶® ‡¶â‡¶™‡¶∏‡¶∞‡ßç‡¶ó ‡¶¶‡ßá‡¶ñ‡¶æ ‡¶¶‡¶ø‡¶≤‡ßá ‡¶ö‡¶ø‡¶ï‡¶ø‡ßé‡¶∏‡¶ï‡ßá‡¶∞ ‡¶∏‡¶æ‡¶•‡ßá ‡¶Ø‡ßã‡¶ó‡¶æ‡¶Ø‡ßã‡¶ó ‡¶ï‡¶∞‡ßÅ‡¶®\n‚Ä¢ ‡¶™‡ßá‡¶ü ‡¶ñ‡¶æ‡¶∞‡¶æ‡¶™ ‡¶π‡¶≤‡ßá ‡¶ñ‡¶æ‡¶¨‡¶æ‡¶∞‡ßá‡¶∞ ‡¶∏‡¶æ‡¶•‡ßá ‡¶ì‡¶∑‡ßÅ‡¶ß ‡¶ñ‡¶æ‡¶®\n‚Ä¢ ‡¶ö‡ßÅ‡¶≤‡¶ï‡¶æ‡¶®‡¶ø ‡¶¨‡¶æ ‡¶∞‚Äç‡ßç‡¶Ø‡¶æ‡¶∂ ‡¶π‡¶≤‡ßá ‡¶ì‡¶∑‡ßÅ‡¶ß ‡¶¨‡¶®‡ßç‡¶ß ‡¶ï‡¶∞‡ßá ‡¶ö‡¶ø‡¶ï‡¶ø‡ßé‡¶∏‡¶ï‡ßá‡¶∞ ‡¶™‡¶∞‡¶æ‡¶Æ‡¶∞‡ßç‡¶∂ ‡¶®‡¶ø‡¶®\n‚Ä¢ ‡¶Æ‡¶æ‡¶•‡¶æ ‡¶ò‡ßã‡¶∞‡¶æ ‡¶¨‡¶æ ‡¶¶‡ßÅ‡¶∞‡ßç‡¶¨‡¶≤‡¶§‡¶æ ‡¶π‡¶≤‡ßá ‡¶¨‡¶ø‡¶∂‡ßç‡¶∞‡¶æ‡¶Æ ‡¶®‡¶ø‡¶®\n\n‡¶ï‡ßã‡¶® ‡¶®‡¶ø‡¶∞‡ßç‡¶¶‡¶ø‡¶∑‡ßç‡¶ü ‡¶ì‡¶∑‡ßÅ‡¶ß‡ßá‡¶∞ ‡¶™‡¶æ‡¶∞‡ßç‡¶∂‡ßç‡¶¨‡¶™‡ßç‡¶∞‡¶§‡¶ø‡¶ï‡ßç‡¶∞‡¶ø‡¶Ø‡¶º‡¶æ ‡¶ú‡¶æ‡¶®‡¶§‡ßá ‡¶ö‡¶æ‡¶®? ü§î`
      }
    }
    
    // Simple greetings
    const greetings = ['hello', 'hi', '‡¶∏‡¶æ‡¶≤‡¶æ‡¶Æ', '‡¶Ü‡¶∏‡¶∏‡¶æ‡¶≤‡¶æ‡¶Æ‡ßÅ ‡¶Ü‡¶≤‡¶æ‡¶á‡¶ï‡ßÅ‡¶Æ', '‡¶π‡ßç‡¶Ø‡¶æ‡¶≤‡ßã', '‡¶π‡¶æ‡¶á', '‡¶®‡¶Æ‡¶∏‡ßç‡¶ï‡¶æ‡¶∞']
    if (greetings.some(greeting => lowerMessage.includes(greeting))) {
      let response = `‡¶Ü‡¶∏‡¶∏‡¶æ‡¶≤‡¶æ‡¶Æ‡ßÅ ‡¶Ü‡¶≤‡¶æ‡¶á‡¶ï‡ßÅ‡¶Æ! üôè\n\n‡¶Ü‡¶Æ‡¶ø MediLens ‡¶è‡¶∞ AI ‡¶∏‡¶π‡¶æ‡¶Ø‡¶º‡¶ï‡•§ ‡¶Ü‡¶Æ‡¶ø ‡¶Ü‡¶™‡¶®‡¶æ‡¶ï‡ßá ‡¶∏‡ßç‡¶¨‡¶æ‡¶∏‡ßç‡¶•‡ßç‡¶Ø ‡¶¨‡¶ø‡¶∑‡¶Ø‡¶º‡¶ï ‡¶Ø‡ßá‡¶ï‡ßã‡¶®‡ßã ‡¶™‡ßç‡¶∞‡¶∂‡ßç‡¶®‡ßá‡¶∞ ‡¶â‡¶§‡ßç‡¶§‡¶∞ ‡¶¶‡¶ø‡¶§‡ßá ‡¶™‡¶æ‡¶∞‡¶ø!`
      
      if (prescriptionData) {
        response += `\n\nüî¨ **‡¶Ü‡¶™‡¶®‡¶æ‡¶∞ ‡¶™‡ßç‡¶∞‡ßá‡¶∏‡¶ï‡ßç‡¶∞‡¶ø‡¶™‡¶∂‡¶® ‡¶¨‡¶ø‡¶∂‡ßç‡¶≤‡ßá‡¶∑‡¶£ ‡¶ï‡¶∞‡¶æ ‡¶π‡¶Ø‡¶º‡ßá‡¶õ‡ßá!**\n\n‡¶Ü‡¶™‡¶®‡¶ø ‡¶®‡¶ø‡¶Æ‡ßç‡¶®‡¶≤‡¶ø‡¶ñ‡¶ø‡¶§ ‡¶¨‡¶ø‡¶∑‡¶Ø‡¶º‡ßá ‡¶™‡ßç‡¶∞‡¶∂‡ßç‡¶® ‡¶ï‡¶∞‡¶§‡ßá ‡¶™‡¶æ‡¶∞‡ßá‡¶®:\n‚Ä¢ ‡¶ì‡¶∑‡ßÅ‡¶ß‡ßá‡¶∞ ‡¶¨‡¶ø‡¶∏‡ßç‡¶§‡¶æ‡¶∞‡¶ø‡¶§ ‡¶§‡¶•‡ßç‡¶Ø\n‚Ä¢ ‡¶∏‡ßá‡¶¨‡¶®‡¶¨‡¶ø‡¶ß‡¶ø ‡¶ì ‡¶∏‡¶Æ‡¶Ø‡¶º‡¶∏‡ßÇ‡¶ö‡¶ø\n‚Ä¢ ‡¶™‡¶æ‡¶∞‡ßç‡¶∂‡ßç‡¶¨‡¶™‡ßç‡¶∞‡¶§‡¶ø‡¶ï‡ßç‡¶∞‡¶ø‡¶Ø‡¶º‡¶æ\n‚Ä¢ ‡¶ñ‡¶æ‡¶¶‡ßç‡¶Ø‡¶æ‡¶≠‡ßç‡¶Ø‡¶æ‡¶∏ ‡¶ì ‡¶∏‡¶§‡¶∞‡ßç‡¶ï‡¶§‡¶æ`
      } else {
        response += `\n\nü©∫ **‡¶Ü‡¶Æ‡¶ø ‡¶∏‡¶æ‡¶π‡¶æ‡¶Ø‡ßç‡¶Ø ‡¶ï‡¶∞‡¶§‡ßá ‡¶™‡¶æ‡¶∞‡¶ø:**\n‚Ä¢ ‡¶∞‡ßã‡¶ó‡ßá‡¶∞ ‡¶≤‡¶ï‡ßç‡¶∑‡¶£ ‡¶ì ‡¶ö‡¶ø‡¶ï‡¶ø‡ßé‡¶∏‡¶æ\n‚Ä¢ ‡¶ì‡¶∑‡ßÅ‡¶ß‡ßá‡¶∞ ‡¶§‡¶•‡ßç‡¶Ø ‡¶ì ‡¶¨‡ßç‡¶Ø‡¶¨‡¶π‡¶æ‡¶∞\n‚Ä¢ ‡¶∏‡ßç‡¶¨‡¶æ‡¶∏‡ßç‡¶•‡ßç‡¶Ø ‡¶™‡¶∞‡¶æ‡¶Æ‡¶∞‡ßç‡¶∂ ‡¶ì ‡¶ü‡¶ø‡¶™‡¶∏\n‚Ä¢ ‡¶™‡ßç‡¶∞‡ßá‡¶∏‡¶ï‡ßç‡¶∞‡¶ø‡¶™‡¶∂‡¶® ‡¶¨‡ßÅ‡¶ù‡¶§‡ßá ‡¶∏‡¶æ‡¶π‡¶æ‡¶Ø‡ßç‡¶Ø`
      }
      
      response += `\n\n‡¶Ü‡¶™‡¶®‡¶æ‡¶∞ ‡¶ï‡ßã‡¶® ‡¶™‡ßç‡¶∞‡¶∂‡ßç‡¶® ‡¶Ü‡¶õ‡ßá? üí¨`
      return response
    }
    
    // Default enhanced response
    let defaultResponse = `ü©∫ **MediLens ‡¶∏‡ßç‡¶¨‡¶æ‡¶∏‡ßç‡¶•‡ßç‡¶Ø ‡¶∏‡¶π‡¶æ‡¶Ø‡¶º‡¶ï**\n\n‡¶Ü‡¶™‡¶®‡¶æ‡¶∞ ‡¶™‡ßç‡¶∞‡¶∂‡ßç‡¶®‡¶ü‡¶ø ‡¶Ü‡¶∞‡ßã ‡¶∏‡ßç‡¶™‡¶∑‡ßç‡¶ü ‡¶ï‡¶∞‡ßá ‡¶ú‡¶æ‡¶®‡¶æ‡¶≤‡ßá ‡¶Ü‡¶Æ‡¶ø ‡¶Ü‡¶∞‡ßã ‡¶≠‡¶æ‡¶≤‡ßã ‡¶∏‡¶æ‡¶π‡¶æ‡¶Ø‡ßç‡¶Ø ‡¶ï‡¶∞‡¶§‡ßá ‡¶™‡¶æ‡¶∞‡¶¨‡•§`
    
    if (prescriptionData) {
      defaultResponse += `\n\nüî¨ **‡¶Ü‡¶™‡¶®‡¶æ‡¶∞ ‡¶™‡ßç‡¶∞‡ßá‡¶∏‡¶ï‡ßç‡¶∞‡¶ø‡¶™‡¶∂‡¶®‡ßá‡¶∞ ‡¶§‡¶•‡ßç‡¶Ø ‡¶Ü‡¶õ‡ßá‡•§** ‡¶®‡¶ø‡¶Æ‡ßç‡¶®‡¶≤‡¶ø‡¶ñ‡¶ø‡¶§ ‡¶¨‡¶ø‡¶∑‡¶Ø‡¶º‡ßá ‡¶™‡ßç‡¶∞‡¶∂‡ßç‡¶® ‡¶ï‡¶∞‡¶§‡ßá ‡¶™‡¶æ‡¶∞‡ßá‡¶®:\n‚Ä¢ "‡¶ì‡¶∑‡ßÅ‡¶ß‡ßá‡¶∞ ‡¶§‡¶æ‡¶≤‡¶ø‡¶ï‡¶æ ‡¶¶‡ßá‡¶ñ‡¶æ‡¶®"\n‚Ä¢ "‡¶™‡¶æ‡¶∞‡ßç‡¶∂‡ßç‡¶¨‡¶™‡ßç‡¶∞‡¶§‡¶ø‡¶ï‡ßç‡¶∞‡¶ø‡¶Ø‡¶º‡¶æ ‡¶ï‡ßÄ?"\n‚Ä¢ "‡¶∏‡ßá‡¶¨‡¶®‡¶¨‡¶ø‡¶ß‡¶ø ‡¶ï‡ßÄ?"\n‚Ä¢ "‡¶ñ‡¶æ‡¶¶‡ßç‡¶Ø ‡¶®‡¶ø‡¶Ø‡¶º‡¶Æ ‡¶ï‡ßÄ?"`
    } else {
      defaultResponse += `\n\n**üî• ‡¶ú‡¶®‡¶™‡ßç‡¶∞‡¶ø‡¶Ø‡¶º ‡¶™‡ßç‡¶∞‡¶∂‡ßç‡¶®‡¶∏‡¶Æ‡ßÇ‡¶π:**\n‚Ä¢ "‡¶ú‡ßç‡¶¨‡¶∞ ‡¶π‡¶≤‡ßá ‡¶ï‡¶ø ‡¶ï‡¶∞‡¶¨?"\n‚Ä¢ "‡¶°‡¶æ‡¶Ø‡¶º‡¶æ‡¶¨‡ßá‡¶ü‡¶ø‡¶∏ ‡¶®‡¶ø‡¶Ø‡¶º‡¶®‡ßç‡¶§‡ßç‡¶∞‡¶£‡ßá‡¶∞ ‡¶â‡¶™‡¶æ‡¶Ø‡¶º?"\n‚Ä¢ "‡¶∞‡¶ï‡ßç‡¶§‡¶ö‡¶æ‡¶™ ‡¶¨‡ßá‡¶∂‡¶ø ‡¶π‡¶≤‡ßá ‡¶ï‡¶ø ‡¶ñ‡¶æ‡¶¨?"\n‚Ä¢ "‡¶Æ‡¶æ‡¶•‡¶æ‡¶¨‡ßç‡¶Ø‡¶•‡¶æ‡¶∞ ‡¶ì‡¶∑‡ßÅ‡¶ß ‡¶ï‡¶ø?"`
    }
    
    defaultResponse += `\n\n‡¶Ü‡¶™‡¶®‡¶æ‡¶∞ ‡¶∏‡ßç‡¶¨‡¶æ‡¶∏‡ßç‡¶•‡ßç‡¶Ø‡ßá‡¶∞ ‡¶Ø‡¶§‡ßç‡¶® ‡¶®‡¶ø‡¶®, MediLens ‡¶Ü‡¶™‡¶®‡¶æ‡¶∞ ‡¶™‡¶æ‡¶∂‡ßá! üíö`
    return defaultResponse
  }

  const quickQuestions = [
    '‡¶Ü‡¶∏‡¶∏‡¶æ‡¶≤‡¶æ‡¶Æ‡ßÅ ‡¶Ü‡¶≤‡¶æ‡¶á‡¶ï‡ßÅ‡¶Æ',
    prescriptionData ? '‡¶ì‡¶∑‡ßÅ‡¶ß‡ßá‡¶∞ ‡¶§‡¶æ‡¶≤‡¶ø‡¶ï‡¶æ' : '‡¶ú‡ßç‡¶¨‡¶∞ ‡¶π‡¶≤‡ßá ‡¶ï‡¶ø ‡¶ï‡¶∞‡¶¨?',
    prescriptionData ? '‡¶™‡¶æ‡¶∞‡ßç‡¶∂‡ßç‡¶¨‡¶™‡ßç‡¶∞‡¶§‡¶ø‡¶ï‡ßç‡¶∞‡¶ø‡¶Ø‡¶º‡¶æ' : '‡¶∞‡¶ï‡ßç‡¶§‡¶ö‡¶æ‡¶™ ‡¶¨‡ßá‡¶∂‡¶ø ‡¶π‡¶≤‡ßá ‡¶ï‡¶ø ‡¶ñ‡¶æ‡¶¨?',
    prescriptionData ? '‡¶∏‡ßá‡¶¨‡¶®‡¶¨‡¶ø‡¶ß‡¶ø' : '‡¶°‡¶æ‡¶Ø‡¶º‡¶æ‡¶¨‡ßá‡¶ü‡¶ø‡¶∏ ‡¶ï‡¶®‡ßç‡¶ü‡ßç‡¶∞‡ßã‡¶≤ ‡¶ï‡¶∞‡¶æ‡¶∞ ‡¶â‡¶™‡¶æ‡¶Ø‡¶º?',
    prescriptionData ? '‡¶ñ‡¶æ‡¶¶‡ßç‡¶Ø ‡¶®‡¶ø‡¶Ø‡¶º‡¶Æ' : '‡¶Æ‡¶æ‡¶•‡¶æ‡¶¨‡ßç‡¶Ø‡¶•‡¶æ‡¶∞ ‡¶ì‡¶∑‡ßÅ‡¶ß ‡¶ï‡¶ø?',
    '‡¶™‡ßá‡¶ü ‡¶¨‡ßç‡¶Ø‡¶•‡¶æ‡¶∞ ‡¶ï‡¶æ‡¶∞‡¶£ ‡¶ï‡¶ø?',
    '‡¶ï‡¶æ‡¶∂‡¶ø‡¶∞ ‡¶ò‡¶∞‡ßã‡¶Ø‡¶º‡¶æ ‡¶ö‡¶ø‡¶ï‡¶ø‡ßé‡¶∏‡¶æ',
    '‡¶π‡¶æ‡¶∞‡ßç‡¶ü‡ßá‡¶∞ ‡¶∏‡¶Æ‡¶∏‡ßç‡¶Ø‡¶æ‡¶∞ ‡¶≤‡¶ï‡ßç‡¶∑‡¶£'
  ]

  if (!currentUser) {
    return (
      <div className="min-h-screen bg-base-100 flex items-center justify-center">
        <div className="text-center">
          <h1 className="text-2xl font-bold mb-4">Please log in to chat</h1>
          <a href="/auth/login" className="btn btn-primary">Login</a>
        </div>
      </div>
    )
  }

  if (loading) {
    return (
      <div className="min-h-screen bg-base-100 flex items-center justify-center">
        <div className="text-center">
          <span className="loading loading-spinner loading-lg"></span>
          <p className="mt-4">Loading your chat...</p>
        </div>
      </div>
    )
  }

  return (
    <div className="min-h-screen bg-base-100">
      <Navigation />
      <div className="flex h-screen pt-16">
        {/* Sidebar - Chat History - Hidden on mobile, shown on desktop */}
        <div className="hidden lg:block w-1/4 bg-base-200 border-r">
          <div className="p-4 border-b">
            <button 
              onClick={() => createNewChat()}
              className="btn btn-primary btn-sm w-full"
            >
              ‚ûï ‡¶®‡¶§‡ßÅ‡¶® ‡¶ö‡ßç‡¶Ø‡¶æ‡¶ü
            </button>
          </div>
          <div className="overflow-y-auto h-full">
            {chatHistory.map((chat) => (
              <ChatItem
                key={chat.id}
                chat={chat}
                isSelected={selectedChatId === chat.id}
                onSelect={() => {
                  setSelectedChatId(chat.id)
                  loadChatMessages(chat.id)
                }}
              />
            ))}
            {chatHistory.length === 0 && (
              <div className="p-4 text-center text-base-content/60">
                <p className="text-sm">‡¶ï‡ßã‡¶® ‡¶ö‡ßç‡¶Ø‡¶æ‡¶ü ‡¶®‡ßá‡¶á</p>
                <p className="text-xs mt-1">‡¶®‡¶§‡ßÅ‡¶® ‡¶ö‡ßç‡¶Ø‡¶æ‡¶ü ‡¶∂‡ßÅ‡¶∞‡ßÅ ‡¶ï‡¶∞‡ßÅ‡¶®</p>
              </div>
            )}
          </div>
        </div>

        {/* Main Chat Area */}
        <div className="flex-1 flex flex-col max-w-4xl mx-auto">
          {/* Header */}
          <motion.div 
            className={`${prescriptionData ? 'bg-success' : 'bg-primary'} text-primary-content p-4`}
            initial={{ opacity: 0, y: -20 }}
            animate={{ opacity: 1, y: 0 }}
            transition={{ duration: 0.6 }}
          >
            <div className="flex items-center justify-between">
              <div className="text-center flex-1">
                <h1 className="text-xl lg:text-2xl font-bold">
                  {prescriptionData ? 'üî¨ ‡¶™‡ßç‡¶∞‡ßá‡¶∏‡¶ï‡ßç‡¶∞‡¶ø‡¶™‡¶∂‡¶® AI ‡¶∏‡¶π‡¶æ‡¶Ø‡¶º‡¶ï' : 'ü§ñ MediLens AI Assistant'}
                </h1>
                <p className="text-primary-content/80 text-sm lg:text-base">
                  {prescriptionData ? '‡¶Ü‡¶™‡¶®‡¶æ‡¶∞ ‡¶™‡ßç‡¶∞‡ßá‡¶∏‡¶ï‡ßç‡¶∞‡¶ø‡¶™‡¶∂‡¶® ‡¶¨‡¶ø‡¶∑‡¶Ø‡¶º‡¶ï ‡¶∏‡¶π‡¶æ‡¶Ø‡¶º‡¶ï' : '‡¶Ü‡¶™‡¶®‡¶æ‡¶∞ ‡¶∏‡ßç‡¶¨‡¶æ‡¶∏‡ßç‡¶•‡ßç‡¶Ø ‡¶¨‡¶ø‡¶∑‡¶Ø‡¶º‡¶ï ‡¶∏‡¶π‡¶æ‡¶Ø‡¶º‡¶ï'}
                </p>
              </div>
              {/* Mobile: New Chat Button */}
              <div className="lg:hidden">
                <button 
                  onClick={() => createNewChat()}
                  className="btn btn-sm btn-ghost"
                  disabled={isTyping}
                >
                  ‚ûï
                </button>
              </div>
            </div>
          </motion.div>

          {/* Messages */}
          <div className="flex-1 overflow-y-auto p-4 bg-base-100">
            <div className="space-y-4">
              {messages.filter(message => !message.isHidden).map((message) => (
                <motion.div
                  key={message.id}
                  className={`chat ${message.type === 'user' ? 'chat-end' : 'chat-start'}`}
                  initial={{ opacity: 0, y: 20 }}
                  animate={{ opacity: 1, y: 0 }}
                  transition={{ duration: 0.3 }}
                >
                  <div className="chat-image avatar">
                    <div className="w-10 rounded-full">
                      {message.type === 'user' ? (
                        <div className="w-10 h-10 rounded-full bg-primary flex items-center justify-center text-primary-content font-bold">
                          {currentUser?.firstName?.[0] || 'U'}
                        </div>
                      ) : (
                        <div className={`w-10 h-10 rounded-full ${prescriptionData ? 'bg-success' : 'bg-secondary'} flex items-center justify-center text-secondary-content`}>
                          {prescriptionData ? 'üî¨' : 'ü§ñ'}
                        </div>
                      )}
                    </div>
                  </div>
                  <div className="chat-header">
                    {message.type === 'user' ? `${currentUser?.firstName || 'You'}` : (prescriptionData ? '‡¶™‡ßç‡¶∞‡ßá‡¶∏‡¶ï‡ßç‡¶∞‡¶ø‡¶™‡¶∂‡¶® AI' : 'MediLens AI')}
                    <time className="text-xs opacity-50 ml-2">
                      {message.timestamp.toLocaleTimeString('bn-BD')}
                    </time>
                  </div>
                  <div className={`chat-bubble ${message.type === 'user' ? 'chat-bubble-primary' : (prescriptionData ? 'chat-bubble-success' : 'chat-bubble-secondary')} whitespace-pre-line`}>
                    {message.content}
                  </div>
                </motion.div>
              ))}
              
              {isTyping && (
                <motion.div
                  className="chat chat-start"
                  initial={{ opacity: 0, y: 20 }}
                  animate={{ opacity: 1, y: 0 }}
                  transition={{ duration: 0.3 }}
                >
                  <div className="chat-image avatar">
                    <div className={`w-10 rounded-full ${prescriptionData ? 'bg-success' : 'bg-secondary'} flex items-center justify-center text-secondary-content`}>
                      {prescriptionData ? 'üî¨' : 'ü§ñ'}
                    </div>
                  </div>
                  <div className={`chat-bubble ${prescriptionData ? 'chat-bubble-success' : 'chat-bubble-secondary'}`}>
                    <span className="loading loading-dots loading-sm"></span>
                    <span className="ml-2">‡¶ö‡¶ø‡¶®‡ßç‡¶§‡¶æ ‡¶ï‡¶∞‡¶õ‡¶ø...</span>
                  </div>
                </motion.div>
              )}
              <div ref={messagesEndRef} />
            </div>
          </div>

          {/* Quick Questions */}
          <div className="p-3 lg:p-4 bg-base-200 border-t">
            <p className="text-xs lg:text-sm text-base-content/70 mb-2">
              {prescriptionData ? '‡¶™‡ßç‡¶∞‡ßá‡¶∏‡¶ï‡ßç‡¶∞‡¶ø‡¶™‡¶∂‡¶® ‡¶∏‡¶Æ‡ßç‡¶™‡¶∞‡ßç‡¶ï‡¶ø‡¶§ ‡¶™‡ßç‡¶∞‡¶∂‡ßç‡¶®:' : '‡¶¶‡ßç‡¶∞‡ßÅ‡¶§ ‡¶™‡ßç‡¶∞‡¶∂‡ßç‡¶®:'}
            </p>
            <div className="flex flex-wrap gap-1 lg:gap-2">
              {quickQuestions.slice(0, 8).map((question, index) => (
                <button
                  key={index}
                  className="btn btn-xs lg:btn-sm btn-outline text-xs"
                  onClick={() => {
                    if (!isTyping && !isSending) {
                      setInputMessage(question)
                    }
                  }}
                  disabled={isTyping || isSending}
                >
                  {question}
                </button>
              ))}
            </div>
          </div>

          {/* Input */}
          <form onSubmit={handleSendMessage} className="p-3 lg:p-4 bg-base-200">
            <div className="flex gap-2">
              <input
                type="text"
                value={inputMessage}
                onChange={(e) => setInputMessage(e.target.value)}
                placeholder={prescriptionData ? "‡¶™‡ßç‡¶∞‡ßá‡¶∏‡¶ï‡ßç‡¶∞‡¶ø‡¶™‡¶∂‡¶® ‡¶∏‡¶Æ‡ßç‡¶™‡¶∞‡ßç‡¶ï‡ßá ‡¶™‡ßç‡¶∞‡¶∂‡ßç‡¶® ‡¶ï‡¶∞‡ßÅ‡¶®..." : "‡¶Ü‡¶™‡¶®‡¶æ‡¶∞ ‡¶∏‡ßç‡¶¨‡¶æ‡¶∏‡ßç‡¶•‡ßç‡¶Ø ‡¶¨‡¶ø‡¶∑‡¶Ø‡¶º‡¶ï ‡¶™‡ßç‡¶∞‡¶∂‡ßç‡¶® ‡¶≤‡¶ø‡¶ñ‡ßÅ‡¶®..."}
                className="input input-bordered flex-1 text-sm lg:text-base"
                disabled={isTyping || isSending}
              />
              <button
                type="submit"
                className={`btn ${prescriptionData ? 'btn-success' : 'btn-primary'} ${(isTyping || isSending) ? 'loading' : ''}`}
                disabled={!inputMessage.trim() || isTyping || isSending}
              >
                <span className="hidden lg:inline">
                  {isTyping ? '‡¶™‡¶æ‡¶†‡¶æ‡¶ö‡ßç‡¶õ‡¶ø...' : 'üì§ Send'}
                </span>
                <span className="lg:hidden">
                  {isTyping ? '...' : 'üì§'}
                </span>
              </button>
            </div>
          </form>
        </div>
      </div>
    </div>
  )
}
